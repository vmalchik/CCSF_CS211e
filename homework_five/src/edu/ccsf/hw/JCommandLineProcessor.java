/**Name: Victor Malchikov
 * Class: CS211E
 * Prof: Abbas Moghtanei
 * Homework: 5
 * File: JCommandLineProcessor.java 
 * Description: This is a class that creates an object that allows the user to 
 *              interact with the OS shell. User is able to then pass commands
 *              that are passed to the shell and are executed returning an array
 *              with output information (or null array if no output was generated).
 */

package edu.ccsf.hw;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Scanner;

public class JCommandLineProcessor
{
	private String shell; //OS shell
	private String cOption; //OS option used in ProcessBuilder command creation  
	
	//*******************************JCommandLineProcessor()************************
	public JCommandLineProcessor() 
	{
		//obtain operating system
		String tmp = System.getProperty("os.name");
		//based on OS find shell and assign either /C or -c option 
		if(tmp.contains("Windows") || tmp.contains("Microsoft"))
		{
			//set windows settings 
			shell = "cmd";
			cOption = "/C";

		}
		else
		{
			// set unix/linux settings
			cOption = "-c"; 
			
			//obtain shell via system environment 
			ProcessBuilder pb = new ProcessBuilder();
			shell = pb.environment().get("SHELL");
			if(!shell.isEmpty())
			{
				String delimitor = System.getProperty("file.separator");
				shell = shell.substring(shell.lastIndexOf(delimitor)+1);
			}
			else
				findShell(pb); //else find shell via running process 	
		}
	}
	
	//*************************************findShell()******************************
	private void findShell(ProcessBuilder pb)
	{
		pb.command("ps");
		try
		{
			Process p= pb.start();
			
			//obtain all running processes and scan them for name of shell
			InputStream is = p.getInputStream();
			Scanner sc = new Scanner(is);
			while(sc.hasNextLine())
			{
				String[] container = sc.nextLine().split(" ");
				shell = container[container.length-1];
				//check
				try
				{
					pb.command(shell, cOption, "ls").start();
				}
				catch(IOException e) { continue; }
				//if exception is not thrown then shell name is found
				break;
			}
		}
		catch(IOException e) 
		{ 
			e.printStackTrace();
		}
	}
	
	//*************************************getOS()**********************************
	//get OS name
	public String getOS()
	{
		return System.getProperty("os.name");
	}
	
	//************************************getShell()********************************
	public String getShell()
	{
		return shell;
	}
	
	//*************************************system()*********************************
	public String[] system(String cmd) throws IOException
	{

		//form command for process builder
		ProcessBuilder pb = new ProcessBuilder();
		//create command to be executed
		pb.command(shell, cOption, cmd);
		//ensure that any error will be sent 
		pb.redirectErrorStream(true);
		//execute command
		Process p = pb.start();
		//obtain output (if any)
		InputStream is = p.getInputStream();
		Scanner sc = new Scanner(is);
		//store output into container
		ArrayList<String> output = new ArrayList<>();
		while(sc.hasNextLine())
		{
			output.add(sc.nextLine());
		}
		
		//return null if no output is generated by cmd else return output 
		if(output.isEmpty())
		{
			return null;
		}
		else
		{
			String[] tmp = new String[output.size()];
			return output.toArray(tmp);
		}
	}
}
